# 📋 Notion 페이지 작성 실행 가이드 (범용)

> 💡 **범용 가이드**: 모든 MCP 지원 AI 플랫폼에서 사용 가능

## 🚨 중요: 부모 페이지 지정 시 필수 규칙

> ⚠️ **절대 규칙**: 사용자가 부모 페이지를 지정했는데 API 실패 시, **절대 전역에 페이지를 생성하지 마세요!**
> 
> ✅ **올바른 동작**: API 실패 → **즉시 브라우저 자동화(PlayWright)로 전환** → 부모 페이지 내에 직접 생성
> 
> ❌ **잘못된 동작**: API 실패 → 그냥 전역에 생성하고 완료 보고 (사용자가 원한 위치가 아님!)

---

## 📋 TL;DR (핵심 요약)

**목적**: 마크다운 파일을 Notion 페이지로 업로드하는 실행 절차

**Conditional Logic (우선순위)**:

```
IF 부모 페이지 ID 없음:
  → API로 페이지 생성 (워크스페이스 루트)
  → 내용 업로드 진행

ELSE IF 부모 페이지 ID 있음:
  ❶ API 시도 (페이지 생성 → 부모로 이동)
  
  ❷ API 성공 확인:
     → 성공: 내용 업로드 진행
     → 실패 감지:
        ⚠️ 🚨 절대 여기서 멈추지 마세요! 🚨
        ⚠️ 전역에 생성된 페이지는 무시하세요!
        
  ❸ API 실패 시 즉시 fallback:
     → ✅ 브라우저 자동화(PlayWright)로 전환
     → 부모 페이지 접속
     → /page 명령어로 하위 페이지 생성
     → 제목 입력
     → ⚠️ 필수: 내용 업로드 진행
```

**핵심 규칙**:

- 🚨 **부모 페이지 지정 시 API 실패하면 절대 전역에 생성 금지**
- API 실패 시 **즉시 브라우저 자동화로 전환** (생성된 페이지 무시)
- **실패를 감지하고 다른 방법으로 자동 재시도하는 것이 핵심**
- 모든 단계에서 사용자에게 진행 상황 보고
- 청크는 최대 2,000자/청크
- **⚠️ 기존 페이지 내용 보존 (절대 규칙)**

---

## 📖 단계 1: 파일 읽기 및 분석

1. 사용자가 제공한 `.md` 파일 경로 확인
2. 파일 전체 라인 수 확인
3. 파일 내용 읽기
4. 파일 크기 기반 청크 분할 전략 결정
5. **파일명에서 확장자 제거하여 기본 페이지 제목 생성**

**도구**: `read_file`

**사용자 전달 예시**:

```
📄 단계 1: 파일 읽기 및 분석
- 파일 경로 확인 중...
- 파일 읽기 완료: [파일명].md ([라인수]줄)
- 기본 페이지 제목: [포맷팅된 제목]
- 청크 분할 전략 결정: [전략 설명]
```

---

## 🆕 단계 2: Notion 페이지 생성

### 전략 선택

**실행 흐름도**:

```
부모 페이지 지정됨?
├─ 아니오 → 옵션 A: API로 페이지 생성 (워크스페이스 루트)
└─ 예 → 옵션 A 시도
    ├─ 성공 → 완료
    └─ 실패 (API 오류)
        └─ ⚠️ 즉시 옵션 C로 전환 (생성된 페이지 무시)
            ├─ 부모 페이지 URL 구성 및 변환
            ├─ 부모 페이지 접속
            ├─ 로그인 상태 확인
            ├─ 편집 가능 여부 확인
            ├─ /page 명령어로 하위 페이지 생성
            ├─ 포맷팅된 제목 입력
            └─ 내용 업로드
```

### 옵션 A: API로 새 페이지 생성

**1단계: API로 페이지 생성**

- MCP 도구: `notion-create-pages`
- 제목: 포맷팅된 제목 사용
- parent 생략 시 워크스페이스 루트에 생성

**2단계: 부모 페이지로 이동 시도** (부모 페이지 ID 있는 경우)

- MCP 도구: `notion-move-pages`
- ⚠️ **중요**: API 오류 발생 가능

**3단계: 이동 성공 여부 확인 (🚨 필수)**

실패 감지 방법:
- [ ] API 에러 메시지 확인
- [ ] "권한 없음" / "permission denied" 에러
- [ ] "이동 실패" / "move failed" 에러
- [ ] 타임아웃 발생
- [ ] 반환된 페이지 위치가 부모 페이지가 아님

**4단계: 실제 위치 검증 (🚨 필수 - API 에러 없을 때)**

⚠️ **중요**: API 호출이 성공했다고 해서 반드시 부모 하위에 생성된다는 보장 없음!

**검증 방법 (브라우저 확인)**:

```javascript
// 부모 페이지 접속하여 하위 확인
await browser_navigate({ url: parentPageUrl });
await browser_wait_for({ time: 2 });

const verification = await browser_run_code({
  code: `async (page) => {
    return await page.evaluate((title) => {
      const treeItems = Array.from(document.querySelectorAll('[role="treeitem"]'));
      
      // 현재 페이지 (부모) 찾기 - expanded 또는 aria-current
      let currentPageItem = null;
      for (const item of treeItems) {
        const isExpanded = item.getAttribute('aria-expanded') === 'true';
        const isCurrent = item.querySelector('[aria-current="page"]') !== null;
        if ((isExpanded || isCurrent) && item.querySelector('[role="group"]')) {
          currentPageItem = item;
          break;
        }
      }
      
      if (!currentPageItem) {
        return { success: false, error: "부모 페이지를 찾을 수 없습니다" };
      }
      
      // 하위 그룹 확인
      const parentGroup = currentPageItem.querySelector('[role="group"]');
      if (!parentGroup) {
        return { success: false, hasChildren: false };
      }
      
      // 하위 페이지 목록 확인
      const childItems = Array.from(parentGroup.querySelectorAll('[role="treeitem"]'));
      const hasTargetPage = childItems.some(item => 
        item.textContent.includes(title) || 
        item.textContent.includes('새 페이지') ||
        item.textContent.includes('Untitled')
      );
      
      return {
        success: hasTargetPage,
        hasTargetPage: hasTargetPage,
        childCount: childItems.length
      };
    }, title);
  }`
});

// 검증 실패 시 브라우저 자동화로 전환
if (!verification.success || !verification.hasTargetPage) {
  throw new Error("ERR_API_PAGE_NOT_UNDER_PARENT");
}
```

**검증 실패 신호**:
- ❌ 부모 페이지를 찾을 수 없음
- ❌ 부모 페이지에 하위 그룹 없음
- ❌ 하위 목록에 생성된 페이지 없음

**🚨 필수 전환 규칙**:

> ⚠️ **API 에러 또는 위치 검증 실패 시:**
> 
> ❌ **절대 하지 마세요**: 
> - 전역에 생성된 페이지를 그대로 사용
> - "이동에 실패했지만 페이지는 생성되었습니다" 같은 보고
> - 그냥 다음 단계로 진행
> 
> ✅ **반드시 해야 할 것**:
> 1. 사용자에게 API 실패 보고
> 2. "브라우저 자동화 방식으로 재시도합니다" 알림
> 3. **즉시 옵션 C로 전환**
> 4. 생성된 페이지는 무시 (나중에 사용자가 정리)
> 5. 부모 페이지 내에 새로 생성

### 옵션 C: 부모 페이지 내 직접 생성 (권장)

**1단계: 부모 페이지 접속**

- 부모 페이지 URL 구성
- 공유 페이지 URL → 일반 URL 변환
- 브라우저 도구: `browser_navigate`

**2단계: 로그인 상태 확인**

- 페이지 텍스트 확인
- 로그인 필요 시 사용자에게 요청

**3단계: 편집 가능 여부 확인 (🚨 필수)**

⚠️ **중요**: 공유 페이지는 편집 권한이 제한될 수 있습니다!

**권한 확인 방법**:

```javascript
// 1. contenteditable 영역 확인
const editableAreas = document.querySelectorAll('[contenteditable="true"]');
const hasEditPermission = editableAreas.length > 0;

// 2. 추가 권한 확인 - 하위 페이지 추가 버튼 존재 여부
const addPageButton = document.querySelector('[aria-label*="Add a page"]') ||
                      document.querySelector('[aria-label*="페이지 추가"]');

// 3. 공유 페이지 경고 확인
const isSharedPage = document.body.innerText.includes('공유됨') || 
                     document.body.innerText.includes('Shared');

if (!hasEditPermission || !addPageButton) {
  return {
    success: false,
    error: "ERR_BROWSER_NO_EDIT_PERMISSION",
    message: "페이지 편집 권한이 없습니다",
    isSharedPage: isSharedPage
  };
}
```

**권한 없을 시**:
- 즉시 `ERR_BROWSER_NO_EDIT_PERMISSION` 에러 보고
- 사용자에게 권한 요청 또는 다른 부모 페이지 선택 안내
- 절대로 강제로 진행하지 않음

**4단계: 하위 페이지 생성**

⚠️ **중요**: `/page` 명령어는 동작이 불안정할 수 있습니다!

**권장 방법 A**: UI 버튼 사용 (가장 안정적)
```javascript
// 1. 페이지 제목 옆 "..." 메뉴 버튼 찾기
const menuButton = document.querySelector('[aria-label*="메뉴"]') || 
                   document.querySelector('button[aria-label*="Options"]');

// 2. 메뉴 클릭
menuButton.click();
await new Promise(r => setTimeout(r, 500));

// 3. "Add a page inside" 또는 "페이지 추가" 옵션 클릭
const addPageButton = Array.from(document.querySelectorAll('div[role="button"]'))
  .find(el => el.innerText.includes('페이지 추가') || el.innerText.includes('Add a page inside'));

if (addPageButton) {
  addPageButton.click();
  await new Promise(r => setTimeout(r, 2000)); // 새 페이지 로딩 대기
}
```

**방법 B**: 키보드 단축키 (대체 방법)
- 부모 페이지에서 `Ctrl+Shift+P` (Windows) 또는 `Cmd+Shift+P` (Mac)
- 새 하위 페이지가 즉시 생성됨
- 제목 입력란이 자동으로 포커스됨

**5단계: 페이지 생성 성공 확인 (🚨 필수)**

⚠️ **절대 규칙**: 새 페이지가 **실제로 생성되었는지 반드시 확인**해야 합니다!

**검증 방법**:

```javascript
// 1. 현재 URL 확인 - 새 페이지로 이동했는지
const currentUrl = window.location.href;
const isNewPage = currentUrl !== previousUrl; // 이전 URL과 비교

// 2. 제목 영역 확인 - "Untitled" 또는 빈 제목
const titleElement = document.querySelector('h1[contenteditable="true"]');
const titleText = titleElement?.innerText.trim();
const isNewPageTitle = titleText === 'Untitled' || titleText === '새 페이지' || titleText === '';

// 3. /page 텍스트가 남아있는지 확인 (실패 표시)
const hasPageCommand = document.body.innerText.includes('/page');

// 검증 결과
if (!isNewPage || !titleElement || hasPageCommand) {
  return {
    success: false,
    error: "ERR_PAGE_CREATION_FAILED",
    message: "하위 페이지 생성에 실패했습니다",
    hasPageCommand: hasPageCommand,
    currentUrl: currentUrl
  };
}
```

**실패 신호**:
- ❌ URL이 변경되지 않음
- ❌ 제목 영역(`h1[contenteditable="true"]`)이 없음
- ❌ `/page` 텍스트가 그대로 남아있음
- ❌ 대화상자(dialog)가 열림

**실패 감지 시**:
- **즉시 중단**하고 에러 보고
- `ERR_PAGE_CREATION_FAILED` 에러 발생
- 사용자에게 권한 확인 또는 다른 방법 제시
- ❌ **절대 계속 진행하지 마세요!**

**6단계: 새 페이지 제목 입력 (제목 영역)**

⚠️ **전제 조건**: 5단계 검증 통과 후에만 진행!

- 새로 생성된 페이지의 **제목 영역** 찾기: `h1[contenteditable="true"]`
- 제목 영역에 포커스
- **포맷팅된 제목만** 입력 (예: "노션 셋업 가이드")
- ❌ `/page`를 제목에 쓰지 마세요!
- 브라우저 도구: `browser_evaluate`, `browser_type`

**6-1단계: 제목 입력 검증 (🚨 필수)**

⚠️ **절대 규칙**: 제목이 **정확히 입력되었는지 반드시 확인**해야 합니다!

**검증 방법**:

```javascript
// 제목 입력 검증
const result = await browser_evaluate((expectedTitle) => {
  const titleElement = document.querySelector('h1[contenteditable="true"]');
  const actualTitle = titleElement?.innerText.trim();
  
  // 제목 일치 여부 확인
  if (actualTitle !== expectedTitle) {
    return {
      success: false,
      error: "ERR_TITLE_MISMATCH",
      expected: expectedTitle,
      actual: actualTitle,
      message: "제목이 정확히 입력되지 않았습니다"
    };
  }
  
  return { 
    success: true, 
    title: actualTitle 
  };
}, expectedTitle);

if (!result.success) {
  // 제목 수정 시도 또는 에러 보고
  throw new Error("제목 입력 실패");
}
```

**실패 신호**:
- ❌ 제목이 예상과 다름
- ❌ 제목이 비어있음
- ❌ 제목에 `/page` 같은 명령어가 포함됨

**실패 감지 시**:
- **즉시 제목 수정** 또는 에러 보고
- ❌ **절대 다음 단계로 진행하지 마세요!**

**7단계: 내용 영역으로 안전하게 이동 (🚨 필수)**

⚠️ **절대 규칙**: 내용 입력 전 **제목 영역에서 완전히 벗어나야** 합니다!

**이동 확인 방법**:

```javascript
// 내용 영역으로 이동 및 확인
const result = await browser_evaluate(() => {
  // 1. 제목 영역 확인
  const titleElement = document.querySelector('h1[contenteditable="true"]');
  const isFocusedOnTitle = titleElement?.contains(document.activeElement);
  
  if (isFocusedOnTitle) {
    // 제목 영역에서 벗어나기
    const bodyElement = document.querySelector('[contenteditable="true"]:not(h1)');
    if (bodyElement) {
      bodyElement.focus();
      bodyElement.click();
    }
  }
  
  // 2. 내용 영역 확인
  const contentArea = document.querySelector('[contenteditable="true"]:not(h1)');
  if (!contentArea) {
    return {
      success: false,
      error: "내용 영역을 찾을 수 없습니다"
    };
  }
  
  // 3. 최하단으로 이동
  contentArea.focus();
  const range = document.createRange();
  range.selectNodeContents(contentArea);
  range.collapse(false); // 끝으로
  
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  
  return {
    success: true,
    isTitleArea: false,
    message: "내용 영역으로 이동 완료"
  };
});

if (!result.success) {
  throw new Error("내용 영역 이동 실패");
}
```

**중요**:
- ✅ 제목 영역과 내용 영역이 **명확히 분리**되어야 함
- ✅ 내용 입력 전 **반드시 내용 영역으로 이동**
- ❌ 제목 영역에 내용이 섞이면 안 됨

**8단계: 내용 업로드 프로세스 진행**

⚠️ **전제 조건**: 7단계 내용 영역 이동 완료 후에만 진행!

- ⚠️ **필수**: 이 단계를 생략하면 페이지가 비어있음
- 새 페이지가 이미 열려있으므로 `browser_navigate` 생략
- **각 청크 입력 시 검증 필수** (아래 참조)

---

## ✂️ 단계 3: 청크 분할 전략

| 파일 크기   | 청크 단위       | 예시      |
| ----------- | --------------- | --------- |
| < 500줄     | 1개 청크 (전체) | 작은 문서 |
| 500-2,000줄 | 200-300줄 단위  | 중간 문서 |
| > 2,000줄   | 300-500줄 단위  | 큰 문서   |

**제한**: 각 청크는 최대 2,000자

---

## 🖥️ 단계 4: 내용 업로드

**브라우저 도구 사용**:

- `browser_navigate`: 페이지 열기 (옵션 A 사용 시)
- `browser_evaluate`: 스크롤, 포커스, 클립보드 복사
- `browser_press_key`: Ctrl+V 붙여넣기
- `browser_wait_for`: 대기

**체크리스트**:

- [ ] 옵션 A 사용 시: 페이지 접속
- [ ] 옵션 C 사용 시: 접속 생략 (이미 페이지가 열려있음)
- [ ] 각 청크를 순차적으로 업로드:
  - [ ] **청크 입력 전 검증** (제목 보호 + 위치 확인)
  - [ ] 클립보드에 복사
  - [ ] 페이지 하단으로 스크롤
  - [ ] 편집 영역 포커스
  - [ ] Ctrl+V로 붙여넣기
  - [ ] 1-2초 대기
  - [ ] **청크 입력 후 검증** (제목 변경 확인 + 연결성 확인)
  - [ ] 진행률 보고

**🚨 청크 입력 시 품질 검증 (필수)**

⚠️ **핵심**: 각 청크 입력 전/후 검증으로 **문서 품질 보장**

### 검증 1: 입력 전 - 제목 영역 보호

```javascript
// 청크 입력 전: 제목 영역이 아닌지 확인
const preCheck = await browser_evaluate((expectedTitle) => {
  const titleElement = document.querySelector('h1[contenteditable="true"]');
  const currentTitle = titleElement?.innerText.trim();
  const isFocusedOnTitle = titleElement?.contains(document.activeElement);
  
  // 1. 제목 영역에 포커스되어 있는지 확인
  if (isFocusedOnTitle) {
    return {
      success: false,
      error: "ERR_FOCUSED_ON_TITLE",
      message: "제목 영역에 포커스됨 - 내용 영역으로 이동 필요"
    };
  }
  
  // 2. 제목이 변경되지 않았는지 확인
  if (currentTitle !== expectedTitle) {
    return {
      success: false,
      error: "ERR_TITLE_CHANGED",
      expected: expectedTitle,
      actual: currentTitle,
      message: "제목이 변경됨 - 중단 필요"
    };
  }
  
  return { success: true };
}, expectedTitle);

if (!preCheck.success) {
  // 즉시 중단하고 에러 보고
  throw new Error(preCheck.error);
}
```

### 검증 2: 입력 후 - 제목 변경 확인

```javascript
// 청크 입력 후: 제목이 변경되지 않았는지 확인
const titleCheck = await browser_evaluate((expectedTitle) => {
  const titleElement = document.querySelector('h1[contenteditable="true"]');
  const currentTitle = titleElement?.innerText.trim();
  
  if (currentTitle !== expectedTitle) {
    return {
      success: false,
      error: "ERR_TITLE_CORRUPTED",
      expected: expectedTitle,
      actual: currentTitle,
      message: "제목이 변경됨 - 복구 필요"
    };
  }
  
  return { success: true, title: currentTitle };
}, expectedTitle);

if (!titleCheck.success) {
  // 제목 복구 시도 또는 에러 보고
  throw new Error("제목 변경 감지");
}
```

### 검증 3: 입력 후 - 이전 청크 연결성 확인 (2번째 청크부터)

```javascript
// 청크 입력 후: 이전 청크와 연결되는지 확인 (첫 번째 제외)
if (chunkIndex > 0) {
  const continuityCheck = await browser_evaluate((previousChunkEnd, currentChunkStart) => {
    const bodyText = document.body.innerText;
    
    // 1. 이전 청크의 마지막 부분이 있는지 확인
    const hasPreviousEnd = bodyText.includes(previousChunkEnd);
    
    // 2. 현재 청크의 시작 부분이 있는지 확인
    const hasCurrentStart = bodyText.includes(currentChunkStart);
    
    // 3. 순서가 올바른지 확인 (이전 끝 → 현재 시작)
    const previousEndIndex = bodyText.indexOf(previousChunkEnd);
    const currentStartIndex = bodyText.indexOf(currentChunkStart);
    const isCorrectOrder = previousEndIndex < currentStartIndex;
    
    if (!hasPreviousEnd || !hasCurrentStart) {
      return {
        success: false,
        error: "ERR_CHUNK_MISSING",
        hasPreviousEnd: hasPreviousEnd,
        hasCurrentStart: hasCurrentStart,
        message: "청크가 누락됨"
      };
    }
    
    if (!isCorrectOrder) {
      return {
        success: false,
        error: "ERR_CHUNK_ORDER",
        previousEndIndex: previousEndIndex,
        currentStartIndex: currentStartIndex,
        message: "청크 순서가 잘못됨"
      };
    }
    
    return { 
      success: true,
      message: "청크 연결성 확인 완료",
      previousEndIndex: previousEndIndex,
      currentStartIndex: currentStartIndex
    };
  }, previousChunkEnd, currentChunkStart);
  
  if (!continuityCheck.success) {
    // 순서 문제 또는 누락 감지 - 중단
    throw new Error(continuityCheck.error);
  }
}
```

**청크 연결성 검증 예시**:

```javascript
// 예시: 3개 청크 업로드
const chunks = [
  "첫 번째 청크 내용...",
  "두 번째 청크 내용...",
  "세 번째 청크 내용..."
];

for (let i = 0; i < chunks.length; i++) {
  // 입력 전 검증
  await preCheck(expectedTitle);
  
  // 청크 입력
  await uploadChunk(chunks[i]);
  
  // 입력 후 검증 1: 제목 확인
  await titleCheck(expectedTitle);
  
  // 입력 후 검증 2: 연결성 확인 (첫 번째 제외)
  if (i > 0) {
    const previousEnd = chunks[i - 1].slice(-50); // 이전 청크 마지막 50자
    const currentStart = chunks[i].slice(0, 50);  // 현재 청크 첫 50자
    await continuityCheck(previousEnd, currentStart);
  }
}
```

**대기 시간**:

- 청크 간: 1-2초
- 붙여넣기 후: 2초
- 스크롤 후: 1초
- 포커스 후: 0.5초
- **검증 후**: 0.5초

---

## ✅ 단계 5: 최종 검증

**브라우저 도구**: `browser_evaluate`, `browser_snapshot`

**체크리스트**:

- [ ] **제목 최종 확인** (품질 보장):
  ```javascript
  const titleCheck = await browser_evaluate((expected) => {
    const actual = document.querySelector('h1[contenteditable="true"]')?.innerText.trim();
    return {
      success: actual === expected,
      expected: expected,
      actual: actual
    };
  }, expectedTitle);
  ```
- [ ] **내용 완전성 확인**:
  - [ ] 파일의 마지막 줄 텍스트 확인
  - [ ] 페이지 텍스트 추출
  - [ ] 마지막 줄 텍스트가 페이지에 포함되어 있는지 확인
- [ ] **제목과 내용 분리 확인**:
  ```javascript
  - 제목 영역에 내용이 섞이지 않았는지 확인
  - 내용 영역에 제목이 중복되지 않았는지 확인
  ```
- [ ] 검증 성공 시 페이지 URL 반환

**검증 실패 시**:
- 제목 불일치 → 제목 수정 후 재확인
- 내용 누락 → 누락된 청크 재업로드
- 제목/내용 섞임 → 사용자에게 수동 수정 요청

---

## ✅ 실행 체크리스트 (전체)

### 🔍 1. 초기화

- [ ] 파일 경로 확인 및 읽기
- [ ] 파일 라인 수 확인
- [ ] 제목 포맷팅 (언더스코어 → 공백)
- [ ] 청크 전략 결정
- [ ] Notion 로그인 상태 확인

### 📄 2. 페이지 준비

**옵션 A: API 방식**

- [ ] 제목 생성 및 포맷팅
- [ ] API로 페이지 생성
- [ ] 부모 페이지로 이동 시도 (부모 있는 경우)
- [ ] ⚠️ 이동 실패 감지 및 옵션 C로 전환

**옵션 C: 브라우저 자동화**

- [ ] 부모 페이지 URL 구성 및 접속
- [ ] 로그인 상태 확인
- [ ] 🔍 편집 가능 여부 확인 (필수!)
- [ ] **하위 페이지 생성 (권장 방법 선택)**:
  - 방법 A: UI 메뉴 버튼 사용 (가장 안정적)
  - 방법 B: 키보드 단축키 `Ctrl+Shift+P`
  - ⚠️ `/page` 명령어는 동작이 불안정하여 권장하지 않음
- [ ] 🔍 페이지 생성 성공 확인 (필수!)
- [ ] 새 페이지가 열리면 **제목 영역**에 포맷팅된 제목 입력
- [ ] ❌ 제목에 `/page`나 명령어를 쓰지 않음!
- [ ] 🔍 제목 입력 검증 (필수!)
- [ ] 🔍 내용 영역으로 이동 확인 (필수!)

### 📤 3. 내용 업로드 (품질 검증 포함)

- [ ] 파일을 청크로 분할
- [ ] **각 청크 업로드 시**:
  - [ ] 🔍 입력 전 검증: 제목 영역 아닌지, 제목 변경 안 되었는지 확인
  - [ ] 각 청크를 클립보드에 복사
  - [ ] 페이지 하단으로 스크롤
  - [ ] 편집 영역 포커스
  - [ ] Ctrl+V로 붙여넣기
  - [ ] 🔍 입력 후 검증 1: 제목 변경 확인
  - [ ] 🔍 입력 후 검증 2: 이전 청크 연결성 확인 (2번째부터)
  - [ ] 진행률 보고

### ✅ 4. 최종 검증

- [ ] 제목 최종 확인 (예상 제목과 일치하는지)
- [ ] 파일의 마지막 줄 텍스트 확인
- [ ] 페이지에서 해당 텍스트 검색
- [ ] 검증 성공 시 페이지 URL 반환

---

## 📚 참조

- **메인 가이드**: `00_메인_가이드.md`
- **코드 패턴**: `02_코드_패턴.md`
- **에러 처리**: `03_에러_처리.md`
- **템플릿**: `04_템플릿.md`

---

**Made with ❤️ for AI Agents (Universal)**

---

## 📝 출처

**작성자**: 김준모  
**이메일**: rnsdlsdmtlk@gmail.com  
**버전**: 2.0.0 (Universal)
